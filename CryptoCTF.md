# CryptoCTF

## 1.blue_office

题目：

```
#!/usr/bin/enc python3

import binascii
from secret import seed, flag

def gen_seed(s):
	i, j, k = 0, len(s), 0
	while i < j:
		k = k + ord(s[i])
		i += 1
	i = 0
	while i < j:
		if (i % 2) != 0:
			k = k - (ord(s[i]) * (j - i + 1))            
		else:
			k = k + (ord(s[i]) * (j - i + 1))
	
		k = k % 2147483647
		i += 1

	k = (k * j) % 2147483647
	return k

def reseed(s):
	return s * 214013 + 2531011

def encrypt(s, msg):
	assert s <= 2**32
	c, d = 0, s
	enc, l = b'', len(msg)
	while c < l:
		d = reseed(d)
		enc += (msg[c] ^ ((d >> 16) & 0xff)).to_bytes(1, 'big')
		c += 1
	return enc

enc = encrypt(seed, flag)
print(f'enc = {binascii.hexlify(enc)}')
```

分析encrypt代码，实际只使用了s的低24位，我们只需要爆破2^23-2^24，得到flag

```
from Crypto.Util.number import *
from tqdm import *

enc = long_to_bytes(int('b0cb631639f8a5ab20ff7385926383f89a71bbc4ed2d57142e05f39d434fce',16))

mod = 2**24
for seed in trange(2**23,2**24):
    s = seed
    flag = ""
    for i in range(len(enc)):
        s = (s*214013+2531011)%(mod)
        flag += chr(enc[i] ^ ((s>>16)&0xff))
    if("CCTF" in flag):
        print(flag)

#CCTF{__B4ck_0r!F1c3__C1pHeR_!!}
```

## 2.suction

```
#!/usr/bin/env python3

from Crypto.Util.number import *
#from flag import flag

def keygen(nbit, r):
	while True:
		p, q = [getPrime(nbit) for _ in '__']
		e, n = getPrime(16), p * q
		phi = (p - 1) * (q - 1)
		if GCD(e, phi) == 1:
			N = bin(n)[2:-r]
			E = bin(e)[2:-r]
			PKEY = N + E
			pkey = (n, e)
			return PKEY, pkey

def encrypt(msg, pkey, r):
	m = bytes_to_long(msg)
	n, e = pkey
	c = pow(m, e, n)
	C = bin(c)[2:-r]
	return C

r, nbit = 8, 128
PKEY, pkey = keygen(nbit, r)
print(f'PKEY = {int(PKEY, 2)}')
flag = b'CCTF{111111111111}'
FLAG = flag.lstrip(b'CCTF{').rstrip(b'}')
enc = encrypt(FLAG, pkey, r)
print(f'enc = {int(enc, 2)}')

PKEY = 55208723145458976481271800608918815438075571763947979755496510859604544396672
ENC = 127194641882350916936065994389482700479720132804140137082316257506737630761
```

n，e，c后八位未知，爆破即可

先枚举n

```
from tqdm import trange

PKEY = 55208723145458976481271800608918815438075571763947979755496510859604544396672

bitsequence = f'{PKEY:b}'
N, e = bitsequence[:-8], bitsequence[-8:]
print(len(N))

N, e = map(lambda x: int(x, 2), (N, e))

for i in trange(2^7):
    N_ = N * 2^8 + 2 * i + 1
    fac = factor(N_)
    if (len(fac) == 2):
        for p, alpha in fac:
            if (p.nbits() != 128) or (alpha != 1):
                break
        else:
            print('AOLIGEI!!!')
            print(f'{N_ = }')
            print(f'{fac = }')
```

```text
N_ = 55208723145458976481271800608918815438075571763947979755496510859604544396613
fac = 188473222069998143349386719941755726311 * 292926085409388790329114797826820624883
```

再枚举e，c

```
p,q = [188473222069998143349386719941755726311, 292926085409388790329114797826820624883]
e_h = bin(PKEY)[-8:]
print(e_h)
phi = (p-1)*(q-1)
print(isPrime(p),isPrime(q),int(p).bit_length(),int(q).bit_length())
n = p * q

for i in range(2**8):
    for j in range(2**8):
        c = ENC * 2 ** 8 + i
        e = int(e_h, 2) * 2 ** 8 + j
        if not isPrime(e):
            continue
        d = inverse(e,phi)
        flag = long_to_bytes(pow(c,d,n))
        try:
            print(flag.decode())
        except:
            continue
# 6oRYGy&Dc$G2ZS
```

## 3.polyRSA

```
#!/usr/bin/env python3

from Crypto.Util.number import *
from flag import flag

def keygen(nbit = 64):
	while True:
		k = getRandomNBitInteger(nbit)
		p = k**6 + 7*k**4 - 40*k**3 + 12*k**2 - 114*k + 31377
		q = k**5 - 8*k**4 + 19*k**3 - 313*k**2 - 14*k + 14011
		if isPrime(p) and isPrime(q):
			return p, q

def encrypt(msg, n, e = 31337):
	m = bytes_to_long(msg)
	return pow(m, e, n)

p, q = keygen()
n = p * q
enc = encrypt(flag, n)

print(f'n = {n}')
print(f'enc = {enc}')

n = 44538727182858207226040251762322467288176239968967952269350336889655421753182750730773886813281253762528207970314694060562016861614492626112150259048393048617529867598499261392152098087985858905944606287003243
enc = 37578889436345667053409195986387874079577521081198523844555524501835825138236698001996990844798291201187483119265306641889824719989940722147655181198458261772053545832559971159703922610578530282146835945192532
```

yafu分解n-31377*14011，再遍历因子乘积得到所有64bit的k，检验得到p，q

```
from Crypto.Util.number import *
from gmpy2 import *

n = 44538727182858207226040251762322467288176239968967952269350336889655421753182750730773886813281253762528207970314694060562016861614492626112150259048393048617529867598499261392152098087985858905944606287003243
enc = 37578889436345667053409195986387874079577521081198523844555524501835825138236698001996990844798291201187483119265306641889824719989940722147655181198458261772053545832559971159703922610578530282146835945192532
e = 31337
kk = [9291098683758154336,
9575149845906552808,
10096296300622322744,
10374848816125927528,
10529971948699159316,
12467909525600720704,
13003455292353324256,
13355954357902346858,
15507579641739960526,
16802744278290904366]

for k in kk:
    p = k**6 + 7*k**4 - 40*k**3 + 12*k**2 - 114*k + 31377
    q = k**5 - 8*k**4 + 19*k**3 - 313*k**2 - 14*k + 14011
    
    if p*q == n:
        print(k)
        print("p=",p)
        print("q=",q)
p= 643283537411705740305628932951980193282947161617399648511073637247084756633281705227851997116899660917155562388433
q= 69236541264622983424006730523155879848497267615811216846331072116977059619696253688546503176571
d= invert(e,(p-1)*(q-1))
m = long_to_bytes(pow(enc,d,n))
print(m)
#CCTF{F4C70r!N9_tRIcK5_aR3_fUN_iN_RSA?!!!}
```

## 4.risk

p=a1^4+r,q=a2^4-s,因为rs很小，n开四次方即可得到a1*a2

n=（a1a2）^4+sa1^4+ra2^4+e，令t1=sa1^4，t2=ra2^4，得到t1+t2

t1*t2等于e（a1a2）^4，利用求根公式得到t1t2，遍历得到rs，pq

发现gcd(e,phi)不为1，套用代码求出flag

```
# -*- coding: utf-8 -*-
"""
Created on Sat Nov 30 00:51:13 2024

@author: yinao
"""
from Crypto.Util.number import *
from gmpy2 import *

e,n = (150953688, 373824666550208932851344358703053061405262438259996622188837935528607451817812480600479188884096072016823491996056842120586016323642383543231913508464973502962030059403443181467594283936168384790367731793997013711256520780338341018619858240958105689126133812557401122953030695509876185592917323138313818881164334490044163316692588337720342646339764174333821950301279825316497898035760524780198230860089280791887363472060435443944632303774987556026740232641561706904946900169858650106994947597642013168757868017723456208796677559254390940651802333382820063200360490892131573853635471525711894510477078934343423255983)
c = 275574424285842306309073814038154403551700455145115884031072340378743712325975683329051874910297915882286569143815715537085387363420246497061870251520240399514896001311724695996978111559476733709139080970977190150345474341853495386364275702356438666152069791355990718058189043717952080875207858163490627801836274404446661613239167700736337269924479349700031535265765885064606399858172168036794462235707003475360358004643720927563261787867952228496769300443415094124132722170498229611285689671203272698693505808912907778910378274197503048226322090611405601517624884408718689404556983397217070272851442351897456769883

#part1 factor n
a1a2 = iroot(n,4)[0]
#n=(a1^4+r)(a2^4+s)
#t1=sa1^4,t2=ra2^4
#use Vieta theorem
t1_t2 = n - e - a1a2**4
t1t2 = e*a1a2**4
delta = t1_t2**2-4*t1t2
t1 = (t1_t2+iroot(delta,2)[0])//2
t2 = (t1_t2-iroot(delta,2)[0])//2

for s in range(1,2**14,2):
    if(iroot(t1//s,4)[1]):
        a1 = iroot(t1//s,4)[0]
        r = e // s
        a2 = iroot(t2//r,4)[0]
        break

p = a1**4+r
q = a2**4+s

#part2 get flag
cq = pow(c,inverse(e//72,q-1),q)
PR.<x> = PolynomialRing(Zmod(q))
f = x^72 - cq
resq = f.roots()
for i in resq:
    print(long_to_bytes(int(i[0])))

#CCTF{S!mP1E_A7t4cK_0n_SpEc1aL-5trucTur3D_RSA_pR1me5!}
```

## 5.Insights

```
#!/usr/bin/env sage

from Crypto.Util.number import *
from flag import flag

def getRandomNBits(n):
	nb = '1' + ''.join([str(randint(0, 1)) for _ in range(n - 1)])
	return nb

def getLeader(L, n):
	nb = L + getRandomNBits(n)
	return int(nb, 2)

def genPrime(L, nbit):
	l = len(L)
	assert nbit >= l
	while True:
		p = getLeader(L, nbit - l)
		if is_prime(p):
			return p

def genKey(L, nbit):
	p, q = [genPrime(L, nbit) for _ in '__']
	n = p * q
	d = next_prime(pow(n, 0.2919))
	phi = (p - 1) * (q - 1)
	e = inverse(d, phi)
	pubkey, privkey = (n, e), (p, q)
	return pubkey, privkey

def encrypt(msg, pubkey):
	n, e = pubkey
	m = bytes_to_long(msg)
	c = pow(m, e, n)
	return c

nbit = 1024
L = bin(bytes_to_long(b'Practical'))[2:]
pubkey, privkey = genKey(L, nbit)
p, q = privkey
c = encrypt(flag, pubkey)

print('Information:')
print('-' * 85)
print(f'n = {p * q}')
print(f'e = {pubkey[1]}')
print(f'c = {c}')
print(f'p = {bin(p)[2:len(L)]}...[REDACTED]')
print(f'q = {bin(q)[2:len(L)]}...[REDACTED]')
print('-' * 85)
```

题目中给出d，秒解

```
from Crypto.Util.number import *
from gmpy2 import next_prime

n = ..
e = ..
c = ..

d = next_prime(int(pow(n, 0.2919)))
print(long_to_bytes(ZZ(pow(c,d,n))))
```

## 6.Derik

```
#!/usr/bin/env python3

from Crypto.Util.number import *
from secret import C, e, d, p, q, r, flag

O = [1391526622949983, 2848691279889518, 89200900157319, 31337]
C = [5960650533801939766973431801711817334521794480800845853788489396583576739362531091881299990317357532712965991685855356736023156123272639095501827949743772, 6521307334196962312588683933194431457121496634106944587943458360009084052009954473233805656430247044180398241991916007097053259167347016989949709567530079, 1974144590530162761749719653512492399674271448426179161347522113979158665904709425021321314572814344781742306475435350045259668002944094011342611452228289, 2613994669316609213059728351496129310385706729636898358367479603483933513667486946164472738443484347294444234222189837370548518512002145671578950835894451, 8127380985210701021743355783483366664759506587061015828343032669060653534242331741280215982865084745259496501567264419306697788067646135512747952351628613, 5610271406291656026350079703507496574797593266125358942992954619413518379131260031910808827754539354830563482514244310277292686031300804846114623378588204, 10543, 4]
assert isPrime(e) and isPrime(d) and isPrime(p) and isPrime(q) and isPrime(r)
assert C[0] * p - C[1] * q >= 0
assert C[2] * q - C[3] * r >= 0
assert C[4] * r - C[5] * p >= 0
assert (C[0] * p - C[1] * q) ** e + (C[2] * q - C[3] * r) ** e + (C[4] * r - C[5] * p) ** e == d * (C[0] * p - C[1] * q) * (C[2] * q - C[3] * r) * (C[4] * r - C[5] * p)
assert C[6] * e - C[7] * d == O[3]
c = 80607532565510116966388633842290576008441185412513199071132245517888982730482694498575603226192340250444218146275844981580541820190393565327655055810841864715587561905777565790204415381897361016717820490400344469662479972681922265843907711283466105388820804099348169127917445858990935539611525002789966360469324052731259957798534960845391898385316664884009395500706952606508518095360995300436595374193777531503846662413864377535617876584843281151030183895735511854

n = e * d * p * q * r
m = bytes_to_long(flag)
c = pow(m, 65537, n)
print(f'C = {C}')
print(f'c = {c}')
```

根据assert C[6] * e - C[7] * d == O[3]爆破e，d

根据a^3+b^3+c^3>73*a*b*c猜测前三个约束均为0，sage创建方程求解pqr，得到flag

```
# -*- coding: utf-8 -*-
"""
Created on Tue Dec  3 00:36:29 2024

@author: yinao
"""
from Crypto.Util.number import *

C = [5960650533801939766973431801711817334521794480800845853788489396583576739362531091881299990317357532712965991685855356736023156123272639095501827949743772, 6521307334196962312588683933194431457121496634106944587943458360009084052009954473233805656430247044180398241991916007097053259167347016989949709567530079, 1974144590530162761749719653512492399674271448426179161347522113979158665904709425021321314572814344781742306475435350045259668002944094011342611452228289, 2613994669316609213059728351496129310385706729636898358367479603483933513667486946164472738443484347294444234222189837370548518512002145671578950835894451, 8127380985210701021743355783483366664759506587061015828343032669060653534242331741280215982865084745259496501567264419306697788067646135512747952351628613, 5610271406291656026350079703507496574797593266125358942992954619413518379131260031910808827754539354830563482514244310277292686031300804846114623378588204, 10543, 4]
c = 80607532565510116966388633842290576008441185412513199071132245517888982730482694498575603226192340250444218146275844981580541820190393565327655055810841864715587561905777565790204415381897361016717820490400344469662479972681922265843907711283466105388820804099348169127917445858990935539611525002789966360469324052731259957798534960845391898385316664884009395500706952606508518095360995300436595374193777531503846662413864377535617876584843281151030183895735511854
O = [1391526622949983, 2848691279889518, 89200900157319, 31337]

print(c.bit_length())
print(C[6],C[7],O[3])
# C[6] * e - C[7] * d == O[3]
for k in range(-10000,10):
    e = -31337 - 4 * k
    d = -82604332 - 10543 * k
    assert C[6] * e - C[7] * d == O[3]
    if isPrime(e) and isPrime(d):
        print(e,d)

# sage
# C = [5960650533801939766973431801711817334521794480800845853788489396583576739362531091881299990317357532712965991685855356736023156123272639095501827949743772, 6521307334196962312588683933194431457121496634106944587943458360009084052009954473233805656430247044180398241991916007097053259167347016989949709567530079, 1974144590530162761749719653512492399674271448426179161347522113979158665904709425021321314572814344781742306475435350045259668002944094011342611452228289, 2613994669316609213059728351496129310385706729636898358367479603483933513667486946164472738443484347294444234222189837370548518512002145671578950835894451, 8127380985210701021743355783483366664759506587061015828343032669060653534242331741280215982865084745259496501567264419306697788067646135512747952351628613, 5610271406291656026350079703507496574797593266125358942992954619413518379131260031910808827754539354830563482514244310277292686031300804846114623378588204, 10543, 4]
# p,q,r = var('p q r')
# f1 = C[0] * p - C[1] * q - 1391526622949983
# f2 = C[2] * q - C[3] * r - 2848691279889518
# f3 = C[4] * r - C[5] * p - 89200900157319
# solve([f1==0,f2==0,f3==0],p,q,r)
p = 9758621034843917661145412977193922808892309951663464821517963113005483457886774294910761723767526582514514505278091600074371768233672585649562672245905811
q = 8919642442779618620315315582249815126044061421894622037450496385178083791083142991676417756698881509754110765444929271564991855378540939292428839562446571
r = 6736304432663651651650099104581016800112378771266600017972326085742513966258250417227421932482058281545032658577816441378170466639375931780967727070265551

assert O[0] ** 3 + O[1] ** 3 + O[2] ** 3 == 73 * O[0] * O[1] * O[2]
e = 3
d = 73
f = (p-1)*(q-1)*(r-1)*(e-1)*(d-1)
dd = inverse(65537,f)
print(long_to_bytes(pow(c,dd,p*q*r*e*d)))
#CCTF{____Sylvester____tHE0r3m_Of_D3r!va7i0n!}
```

## 7.ASIv

```
#!/usr/bin/env python3

from Crypto.Util.number import *
from flag import flag

def base(n, l):
    D = []
    while n > 0:
        n, r = divmod(n, l)
        D.append(r)
    return ''.join(str(d) for d in reversed(D)) or '0'

def asiv_prng(seed):
	l = len(seed)
	_seed = base(bytes_to_long(seed), 3)
	_seed = [int(_) for _ in _seed]
	_l = len(_seed)
	R = [[getRandomRange(0, 3) for _ in range(_l)] for _ in range(_l**2)]
	S = []
	for r in R:
		s = 0
		for _ in range(_l):
			s += (r[_] * _seed[_]) % 3
		# s += getRandomRange(0, 3)
		s %= 3
		S.append(s)
	return R, S

seed = flag.lstrip(b'CCTF{').rstrip(b'}')
R, S = asiv_prng(seed)

f = open('output.txt', 'w')
f.write(f'R = {R}\nS = {S}')
f.close()
```

输出文件为l^2*l的矩阵R和l^l维向量S，seed为l维向量，R.seed得到S，但直接解l^2维方程复杂度太高，经尝试只使用前3l行矩阵即满秩，求得seed三进制转成十进制即可

```
from sage.all import *

# 读取 output.txt 文件
with open('output.txt', 'r') as f:
    lines = f.readlines()
    R = eval(lines[0].strip().split('= ')[1])  # 解析 R
    S = eval(lines[1].strip().split('= ')[1])  # 解析 S

# 确定 seed 的长度
l = len(R[0])  # R 是一个 l^2 x l 的矩阵
assert len(R) == l * l

# 只使用 R 的前 3*l 行
num_rows_to_use = min(3 * l, len(R))
A = Matrix(ZZ, num_rows_to_use, l)

# 构建线性方程组
for i in range(num_rows_to_use):
    for j in range(l):
        A[i, j] = R[i][j]

# 将 S 的前 num_rows_to_use 个元素转换为向量
b = vector(ZZ, S[:num_rows_to_use])

# 求解线性方程组 A * x ≡ b (mod 3)
# 使用 Sage 的求解函数
# 先将 A 和 b 转换为模 3 的形式
A_mod = A.change_ring(Zmod(3))
b_mod = b.change_ring(Zmod(3))

# 使用 solve 方法来求解
x = A_mod.solve_right(b_mod)

# 输出结果
print("Recovered seed (mod 3):")
print(x)

# 将结果转换为字符串
# 由于 seed 的每个元素在 [0, 2] 范围内，我们需要将其映射回原值
# 假设 seed 的每个元素都是 0, 1, 2 之一
recovered_seed = ''.join(str(int(i)) for i in x)

print("Recovered seed:", recovered_seed)
print(int(recovered_seed,3))
# 进一步将 recovered_seed 转换为字节
# 假设 recovered_seed 的长度与原 seed 相同
# 这里我们可以将其映射回字节
#recovered_bytes = bytes(int(recovered_seed[i:i+1],3) for i in range(len(recovered_seed)))

# 输出最终的 flag
print("Recovered flag:", b'CCTF{' + long_to_bytes(int(recovered_seed,3)) + b'}')
```

